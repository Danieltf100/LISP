(defun jn (L N)
	(cond
		((equal L 'nil) 'nil)
		((equal	(car L) (car N)) 't)
		('t (jn (cdr L) N))
	)
)

(defun incluir (A V)
	(cond
		((equal A 'nil) (reverse (cons V A)))
		((equal (car (car A)) (car V))
				(cond 	((jn (cdr(car A)) (cdr V)) A)
						('t (cons (concatenate 'cons (car A) (cdr V)) (cdr A)))
				)
		)
		('t (incAux (cdr A) A V))
	)
)
(defun IncAux (A B V)
	(cond
		((equal A 'nil) (reverse (cons V B)))
		((equal (car (car A)) (car V))
				(cond 	((jn (cdr(car A)) (cdr V)) B)
						('t (append (peatr A B) (cons (concatenate 'cons (car A) (cdr V)) (cdr A))))
				)
		)
		('t (incAux (cdr A) B V))
	)
)
(defun peatr (A B)
	(cond
		((equal (caar(last B)) (caar A)) (butlast B))
		('t (peatr A (butlast B)))
	)
)
;----------------------------------------------------------- arrumar excluir
(defun excluir (A V)
	(cond
		((equal A 'nil) A)
		((equal (car V) (caar A))
			(cond
				((equal (cadar A) (cadr V)) 
					(cond
						((equal (caddar A) 'nil) (cons (cons (caar A) (cddar A)) (cdr A)))
						('t (cons (peatrc (cdar A) (cons (caar A) 'nil) V) (cdr A)))
					)
				)
			)				
		)
		('t (excAux (cdr A) (car A) V))
	)
)
(defun excAux (A B V)
	(cond
		((equal A 'nil) A)
		((equal (car V) (caar A))
			(cond
				((equal (cadar A) (cdar V)) (cons B (cons (cons (caar A) (cddar A)) (cdr A))))
				('t (cons B (cons (peatrc (cdar A) (caar A) V) (cdr A))))
			)
		)
		('t (excAux (cdr A) (cons B (cons A 'nil)) V))
	)
)
(defun peatrc (A B V)
	(cond
		((equal A 'nil) B)
		((equal (cadr A) (cadr V)) (cons B (cddr A)))
		('t (peatrc (cdr A) (cons B (cadr A)) V))
	)
)
;-----------------------------------------------------------
(defun telefones (A N)
	(cond
		((equal A 'nil) 'INEXISTENTE)
		((equal (caar A) N) (car A))
		('t (telefones (cdr A) N))
	)
)